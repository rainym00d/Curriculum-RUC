<h1>指令系统和汇编语言</h1>

[toc]


## 指令格式
- 指令由两部分组成
  - 操作码字段
  - 地址码字段 
    - 操作数的地址
    - 操作结果的地址
    - 下一条结果的地址
### 不同的指令格式
- **重要，地址码可以是存储器地址，也可以是寄存器名**
- 零地址指令
  - 无需任何操作码，如空操作指令，停机指令等
  - 所需的操作数是默认的（仅存在于堆栈计算机中，操作数就是栈相关的东西）。
- 一地址指令
  - 指令只给出一个地址，该地址既是操作数的存储地址，又是操作结果的存储地址。例如加1、减1等操作
- 二地址指令
  - 第一个地址是操作数的地址，第二个地址是操作数的地址以及操作结果的存储地址
- 三地址指令
  - 第一个和第二个都是操作数的地址，第三个是操作结果的存储地址
### 操作码的扩展
- 指令操作码通常有两种编码格式
  - 固定格式。即操作码长度固定，且集中放在一个字段里。
  - 可变格式。即操作码长度可变，分散地存储在不同的地方
- 扩展的一个例子。
  - 比如说指令长度为16位，包括4位操作码和3个4位地址字段。
  - 现在要放15条三地址指令，15条二地址指令，15条一地址质量，16条零地址指令。
  - 就可以把操作码字段向地址字段作延伸。
## 寻址方式
### 直接寻址
- 指令的地址码部分直接给出操作数在存储器中的地址。
### 寄存器寻址
- 指令的地址码部分给出的是寄存器名，直接到寄存器里找到操作数
### 基址寻址
- 设置一个专用的基址寄存器，操作数的地址由机制寄存器的内容加上地址码$A$得到
- 相当于是访问数组$A[x]$，其中，$A$的地址存在基址寄存器中
### 变址寻址
- 会给出地址$A$（相当于数组$A$的起始地址）与变址寄存器$X$。操作数的地址由地址$A$加上$X$的内容得到
- 要注意与基址寻址的区别
  - 基址寻址相当于是在c++里用$A[x]$来访问，$A$是不变的
  - 变址寻址相当于是在c++里用$A+X$来访问
### 间接寻址
- 寄存器间接寻址
  - 给出寄存器名，会到寄存器里取出内容，这个内容是操作数的地址，于是还得再去访问一次存储器才能得到操作数
- 存储器间接寻址
  - 给出存储器的一个地址，会到这个地址取出内容，这个内容是操作数的地址，于是还得再去访问一次存储器才能获得操作数
### 相对寻址
- 把程序计数器$PC$的内容与指令地址码部分给出的位移量$disp$相加，作为操作数的地址或转移地址。通常用于转移指令
- **$disp$常用补码来表示**，若为$n$位，则可以转移的范围为$PC-2^{n-1}\sim PC+2^{n-1}-1$。因为有一位是符号位，所以在算的时候要注意**补位到底补0还是1**
### 立即数寻址
- 给出的地址码不是地址，而是操作数本身

## 8086寄存器
### 通用寄存器
- 数据寄存器
  - $AX$：累加寄存器（Accumulator）
  - $BX$：基地址寄存器（Base）
  - $CX$：计数器寄存器（Count）
  - $DX$：数据寄存器（Data）
  - **每一个16位数据寄存器都可以分为2个8位寄存器来使用。如$AX$可以分为$AH$和$AL$**
- 指针寄存器
  - $SP$：堆栈指针寄存器（Stack Pointer）
  - $BP$：基指针寄存器（Base Pointer）
    - 记录算术逻辑运算产生的运算结果的标志
- 变址寄存器
  - $SI$：源变址寄存器（Source Index）
  - $DI$：目的变址寄存器（Destination Index）
### 控制寄存器
- 指令指针寄存器
  - $IP$：相当于程序计数器$PC$，记录当前执行指令的地址（Instruction Pointer）
- 标志寄存器
  - $FLAG$：记录算术逻辑运算产生的运算结果的标志
### 段寄存器
- 代码段寄存器
  - $CS$（Code Segment）
- 数据段寄存器
  - $DS$（Data Segment）
- 堆栈段寄存器
  - $SS$（Stack Segment）
- 附加段寄存器
  - $ES$（Extra Segment）
## 各种汇编指令
### 一些规则
- 以下都是$FLAG$里的一些标记
- 当无符号数运算产生溢出时，$CF$为1
- 当有符号数运算产生溢出时，$OF$为1
- 如运算结果为0，$ZF$为1
- 如运算结果为负数，$SF$为1
- 如运算结果中有偶数个1，$PF$为1
- `BYTE PTR`是只取一个字节，即8位
- `WORD PTR`是取一个字，即16位
### MOV指令
- `MOV dest, src`
- 可以支持把立即数赋给寄存器，`MOV AL, 9`（但不能赋值给段寄存器和标志寄存器）
- 如果一个东西加了方括号，那么说明取的是这个东西的内容
### 堆栈操作指令
- `PUSH AX`把$AX$压入栈
- `POP AX`把东西弹出栈，并放入$AX$
- **注意，压栈之后，是$SP$减2，弹栈是加**
- 允许`PUSH CS`，但不允许`POP CS`
### 交换指令
- `XCHG AL, BL`
- `XCHG BX, CX`
- `XCHG [2530], CX`
- 目的操作数和源操作数不能均为内存单元
- 段寄存器和$IP$不能作为交换指令的操作数
### 换码指令
- `XLAT`
- 作用是把$BX+AL$对应位置的内容放到$AL$
### 加法指令
- 不带进位的加法指令
  - `ADD AL, 50H`把$AL$和50H相加，结果放在$AL$中
  - `ADD DI, SI`把$DI$和$SI$的**内容**相加，结果放在$DI$
  - `ADD [BX+DI], AX`把$BX+DI$和$BX+DI+1$两个单元的**内容**和$AX$相加，结果放在$BX+DI$和$BX+DI+1$所指的两个单元
  - `ADD AX, [BX+2000H]`
- 带进位的加法指令
  - `ADC AX, SI`跟上面的差不多，就是还要加上$CF$的值
- 增量指令
  - `INC AL`
  - `INC BYTE PTR [BX+DI+500]`
### 减法指令
- 不考虑借位的减法指令
  - `SUB BX, CX`把$BX$的内容减去$CX$的内容，结果存到$BX$
  - `SUB AL, 20`
- 考虑借位的减法指令
  - `SBB AX, 2030H`跟上面差不多，就是还要减去$CF$
  - `SBB WORD PTR [DI+2], 1000H`
- 减量指令
  - `DEC AX`
  - `DEC BL`
- 求补指令（求补码，取反后加1）
  - `NEG Al`
- 比较指令
  - `CMP AX, 2000H`结果影响$FLAG$中的标志位
  - `CMP AX, CX`
### 乘法指令
- 无符号数的乘法指令
  - `MUL BL`$AL$中的内容和$BL$中的内容相乘，结果放在$AX$
  - `MUL CX`$AX$中的内容和$CX$中的内容相乘，结果放在$DX$和$AX$
- 有符号数的乘法指令
  - `IMUL CL`与上边一样，只是有无符号数的区别
### 除法指令
- 无符号数的除法指令
  - `DIV CL`$AX$的内容除以$CL$的内容，商在$AL$中，余数在$AH$中（8位除法）
  - `DIV WORD PTR [DI]`$DX$和$AX$的内容（32位数）除以$DI$和$DI+1$所指的内容（16位数），商在$AX$，余数在$DX$（16位除法）
  - **要自己确保不会溢出**
- 有符号数的除法指令
  - `IDIV BX`跟上边一样
### BCD码运算指令
- `DAA`对于前面`ADD/ADC`的结果进行调整，**只调整寄存器$AL$的内容**
### 逻辑运算和移位指令（从没用过）
### 程序转移指令
- 
### 简单循环结构
- 定义一个计数器，然后`jnz`
