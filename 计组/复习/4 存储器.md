<h1>存储器</h1>

[toc]

## 主存储器
### 基本概念
- 一般来说，主存储器指内存
- 一般来说，内存在逻辑上用一个线性数组来表示。
  - 以字节为单位，每个字节都有一个全局唯一的地址。
  - 上小下大
- 技术指标（一般不会考这个）：
  - 存储容量（**注意字节$Byte$与位$bit$的区别**）
  - 访问速度（由**访问延迟**与**访问带宽**决定）
- 分类：
  - 随机存储器（$RAM$）
    - 静态$RAM$（不需要刷新）
    - 动态$RAM$（需要刷新）
  - 只读存储器（$ROM$）
    - **这里不知道要不要了解，先空着**
### 组成器件
- 一个存储芯片
  - 地址线（$A_0\sim A_9$）：选择地址的线，后边跟着**地址译码器**来选择内存地址
  - 数据线（$D$）：传输数据的线，可以使传进去，也可以是传出来
  - 片选线（$CS$）：根据信号是否有效，来选择使用哪块存储芯片。就是若这个线的信号是有效的，那么下面的操作就在这个存储芯片里进行。
  - 读写控制线（$R/W$）：来表示是读数据还是写数据
  - 1维地址译码：引线过多，不利于布线
  - 2维地址译码：大大减少了引线数量
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="./pic/截屏2020-12-23%2013.16.03.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">一个存储芯片</div>
</center>

- 地址译码器
  - 输入：$n$条地址线
  - 输出：$2^n$条地址线
  - 但输出中只有一条地址线是有效的
### DRAM的刷新（要会算）
- 要知道的概念：**刷新周期、工作周期**
- 如果一个存储器由多个芯片组成，则**所有芯片同时刷新**；如果一个芯片内有多个矩阵，也是**所有矩阵同时刷新**，只考虑一个矩阵的刷新时间即可。
- 集中式刷新
  - 在一个刷新周期内，在一个连续的时间段内同时刷新存储器的所有行。
- 分布式刷新
  - 在一个刷新周期内，分散地刷新存储器的所有行

## 主存储区模块组成（位扩展、字扩展）
- **考的话会考怎么画电路图**
### 基本概念

- CPU寻址空间
  - CPU可以访问的存储单元地址最大空间，是由CPU地址总线数目决定的
  - 如16位总线，最大访问空间为$2^{16}=64K$
- 存储器空间
  - 指在CPU空间中，实际链接了存储芯片的存储空间，最大不超过CPU寻址空间
- 芯片空间
  - 指一个芯片容纳的存储单元的地址数量
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="./pic/截屏2020-12-23 14.20.41.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">一张非常好的图</div>
</center>

### 位扩展（扩展宽度）

- 位扩展是指用多个存储器器件对字长进行扩充（说白了就是位数不够，而位数在图中画出来就是宽度）
- 形象的理解就是把上图两个短的橙色芯片横向拼在一起，放到最下边的黄色储存器空间
- 方法是将各个芯片的地址控制线$A$、片选控制线$CS$和读写控制线$WE$并联，数据控制线$D$分别引出（读写控制线在这里就是$WE$，write erase的意思，记住就好）
- 画图的时候，一般位扩展是叠在一起画的

### 字扩展（扩展长度）

- 字扩展是增加存储器的字的数量（说白了就是存储容量不够大，而大小在图中画出来就是长度）
- 形象的理解就是把上图两个长的的橙色芯片上下拼在一起，放到最上边的黄色储存器空间
- 方法是将各个芯片的地址控制线$A$、数据控制线$D$和读写控制线$WE$并联，片选控制线$CS$分别引出，由片选信号来区分各芯片的地址范围
- 画图的时候，一般是横着画的

### 字位扩展

- 字扩展与位扩展的同时应用
- 计算方式：
  - 如果一个存储器容量为$M\times N$位，若使用$L\times K$为的存储器芯片。
  - 那么需要的芯片数量为$M/L\times N/K$

## cache
### 基本概念
- cache位于CPU与主存之间，容量比主存小得多，但速度比主存快得多。主要是由于**局部性原理**，因此cache的存在会使得计算机的速度变快。
- 局部性原理
  - 空间局部性
    - 程序很有可能会访问当前数据的周围数据（因为程序存在很多循环。好比去图书馆找书，你找的那类书都会发在一个书架）
  - 时间局部性
    - 程序很有可能会在短期内频繁访问同一块数据（因为程序内有很多变量是需要频繁访问的，如全局变量。好比去图书馆复习，一般只有期末到了才会天天泡图书馆）
- 要会算有了cache之后的**平均存取时间**（有些时候也叫**平均访问时间**）。注意有的机器会先访问cache，未命中再去访问主存；而有的会同时访问cache和主存。（**我们这门课只考虑哪一种？**）

### 地址映像（重点，要会算）
- 约定：
  - 主存有$2^n$个单元，分为$2^m$块，每块大小为$2^b$字节
  - 即主存是 $n=m+b$ 的组成形式。（m位表示块号，b位表示块内地址）
  - cache有$2^c$块，每块大小与主存相同也是$2^b$（**因为之后装入主存都是按块为单位装入**）。注意，cache还有一段标记位，该段的作用是指明它是哪一块主存的副本
  - 即cache是 标记位$+c+b$ 的形式。
- 直接映像
  - $j=i\ mod\ 2^c$。其中$j$是映射后的cache块号，$i$是主存块号。
  - 映射后，地址码为$t+c+b$。其中$t=m-c$，这是因为$2^m\div 2^c=2^{m-c}$，意味着有$2^{m-c}$块可能会映射到同一位置

    |主存字块标记|cache字块地址|块内地址|
    |:-:|:-:|:-:|
    |t = m - c位|c位|b位|
- 全相连映像
  - 没有函数映射，主存的任何一块都可以放入cache的任意位子
  - 由于上面的任意性，导致标记位的长度增加（从$t$增加到$t+c$，即增加到了$m$），并且每次在判断有无命中的时候，都需要扫描一遍cache的**所有块**，这导致效率很慢
    |主存字块标记|块内地址|
    |:-:|:-:|
    |m = t + c位|b位|    
- 组相连映像
  - $j=(i\ mod\ 2^{c'})\times 2^r+k$，其中，$0\le k\le 2^r-1$
  - 把cache的块分成$2^{c'}$组，每组包含$2^r$个块，于是有$c=c'+r$
  - 上面那个函数的意思是：先把这个块号确定分到哪一组，然后$\times 2^r$来定位到它的起始地址，最后加上个偏移量$k$
  - 组相连映像是直接映射与全相连映射的折中方案。相当于**组间采用直接映射，组内采用全相连映射**
    |主存字块标记|组地址|块内地址|
    |:-:|:-:|:-:|
    |t + r位|c’位|b位|
  - 不需要cache字块地址是因为每次都是在一个组里面全部查一次。
  - $t+r$中的$r$是因为$2^m\div 2^{c'}=2^{m-c'}=2^{m-c+r}=2^{t+r}$

### 替换算法
- 先进先出（FIFO）
- 近期最少使用（LRU）




