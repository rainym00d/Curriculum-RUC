<h1>数据的表示和计算</h1>


[toc]

## 各种码

### 原码

- 非常常见的一种编码，什么样的形式就不写了，大家都会的
- 注意一下范围，极限范围那边需要减去1，因为正负各有一个正零与负零。
- 符号位0代表正数，1代表负数

### 补码

- 方便运算
- 以8位举例，范围为$-2^7\sim2^7-1$
- 原码在转换为补码
  - 若是正数，则相同
  - 若是负数，则将数位取反，然后加1
- 补码转换为原码
  - 若是正数，则相同
  - 若是负数，则将数位取反，然后加1
  - **说白了就跟原码转补码相同**

### BCD码

- 课件里主要说的是8421码，用4位表示一个十进制数
- 由于4位表示，所以会有6个数的冗余。因此当值超过最大的十进制数9时，需要加6。即所有的数需要小于等于1001，否则加上0110。

### 浮点数

- 一般表示：$N=M\cdot r^E$，有点类似于科学计数法
  - N：浮点数
  - M：尾数
  - r：底数，一般为2
  - E：阶数
- 计算机中浮点数的构成（4个部分）：
  - 阶码符号位（Es，1位）
  - 尾数符号位（Ms，1位）
  - 阶码（E，n位）
  - 尾数（M，m位）
- 规格化，类似于科学计数法中第一个数一定要有效
  - 规格化作用的是尾数，相应的尾数大小改变也需要去调整阶数大小
  - 原码规格化后，尾数最高位一定是1
  - 补码规格化后，尾数最高位一定与尾数符号位相反
- 规格化后范围
  - 原码
    - 正数为0.1xxxxx的形式，最大为0.1111…1，最小为0.1000…0。范围为$\cfrac{1}{2}\le M\le (1-2^{-n})$
    - 负数为1.1xxxxx的形式，最大为1.10000…0，最小为1.1111…1。范围为$-(1-2^{-n})\le M\le -\cfrac{1}{2}$
  - 补码
    - 正数为0.1xxxxx的形式，最大为0.1111…1，最小为0.1000…0。范围为$\cfrac{1}{2}\le M\le (1-2^{-n})$
    - 负数为1.0xxxxx的形式，最大为1.0111…1，最小为1.000…0。范围为$-1\le M\le -(\cfrac{1}{2}+2^{-n})$

### 奇偶校验码

- 都是添加一位，使得整个码中，1的个数为奇数或是偶数
- 添加位可以是最高位，也可以是最低位
- 只能用来看有没有错，**不能纠正错误**
- 奇校验
  - 添加0或1，使得1的个数为奇数
- 偶校验
  - 添加0或1，使得1的个数为偶数

### 海明校验码

- 多添加好几个校验位，以达到**可以纠错**的能力
- 若校验位个数为$r$，信息位的个数为$k$
  - **要满足关系：$2^r\ge k+r+1$**
  - 因为$r$个校验位可以表示$2^r$个状态，减去一个“没有错误状态”，还剩$2^r-1$个，所以要做到纠错，得保证其大于$k$
- 总的海明校验码一共有$k+r$位，从高到低用$H_{k+r},H_{k+r-1},\ldots,H_1$来表示。
  - 在$2^i$位，存放校验位$P_i$，其余位置按顺序放信息位$D_i$。
  - $P_i$的计算方式为，从连着$2^i$个$H$，再隔着$2^i$个$H$做异或。（**起始位置为自己，但要把自己给去掉**）
- **检查方式：**
  - 通常以$C$来表示检查码。
  - 检查码$C_i$的计算方式为连着$2^i$个$H$，再隔着$2^i$个$H$做异或。（**起始位置为$H_i$，包括它自己**）
  - 若所有的$C$都为0，则说明没错。若不为0，则$C$表示的数位出错位置，将其取反即可。
- 以上的海明校验码**只能纠错1位**，但可以改进成纠错2位的。

### 循环冗余校验码（CRC码）

- 基本思想：在$k$位信息码后面再拼接$r$位的校验码，整个编码长度为$N$位。因此CRC码又称$(N,K)$码
- CRC码需要一个生成多项式，这个多项式不能乱搞，有特定要求，但题目会给。如$G(x)=x^3+x^2+1$，该生成多项式对应的二进制码为$1101$
- 生成CRC码的步骤：
  - 移位：在原信息码后边加上$r$个0
  - 除法：用模2除法来生成商和余数（r位）
  - 生成：原信息码$+$余数就是CRC码
- 校验步骤：
  - 若CRC码除以生成多项式可以整除，则没有错
  - ~~如果有余数，则把余数对应的数位给取反就行了（右往左数）。如余数为010，则把右往左数第二位取反即可。~~（**这里写错了**）

## 原码/补码各种计算
### 原码/补码加减法

- 加法非常简单，但要注意溢出
- 减法要取负转变为加法
- 溢出分为两种：
  - 正数$+$正数导致正溢出，溢出后符号位为负
  - 负数$+$负数导致负溢出，溢出后符号位为正
- 单符号位不能处理溢出，双符号位可以处理溢出

### 原码一位乘法

- 符号位不参与计算，需要单独计算
  - 计算方式为$\oplus$（**异或，相同为0，不同为1**）
- 对于一个n位的数（不包括符号位）
  - 取双符号位
  - 需要算出$|x|$和$|y|$（原码）
  - 乘法次数为$n$次
  - 移位次数为$n$次
  - 移位方向为向右
- **小技巧：乘法次数跟你画横线的次数相同**

### 补码一位乘法（Booth）

- 符号位参与运算
- 要用两位来判断到底是加啥玩意儿，因此**刚开始需要在乘数末尾添加一个0**
  |高位|低位|操作|
  |:-:|:-:|:-:|
  |0|0|加0，右移一位|
  |0|1|加$[x]_{补}$，右移一位|
  |1|0|加$[-x]_{补}$，右移一位|
  |1|1|加0，右移一位|
- 对于一个n位的数（不包括符号位）
  - 取双符号位
  - 需要算出$[x]_补$、$[-x]_补$和$[y]_补$
  - 乘法次数为$n+1$次
  - 移位次数为$n$次
  - 移位方向为向右

### 原码加减交替除法

- 符号位不参与运算
  - 计算方式为$\oplus$（**异或，相同为0，不同为1**）
- 对于一个n位的数（不包括符号位）
  - 取单符号位即可，双符号位没必要
  - 需要算出$|x|$、$|y|$和$[-|y|]_补$（用来代替-y操作）
  - 加减次数为$n+1$或者$n+2$（**若最后余数为负，则需要加上$|y|$来得到正确的余数，所以多一次**）
  - 移位次数为$n$次
  - 移位方向为向左，商补0
  - 结果里商和余数都为原码
- 计算步骤：
  - 初始时，商那边要写成0.0000（**0的数量跟位数有关**）
  - 任何情况下**第一步都是减去被除数，即加上$[-|y|]_补$**
  - 部分余数、商以及该步加减规则：
    - 如果部分余数为负（1），则商上0，这步就加（0）
    - 如果部分余数为正（0），则商上1，这步就减（1）
    - 都是**商上0就加，商上1就减**

### 补码加减交替除法

- 符号位参与运算
- 对于一个n位的数（不包括符号位）
  - 取双符号位
  - 需要算出$[x]_补$、$[y]_补$和$[-y]_补$
  - 加减次数为$n+1$次
  - 移位次数为$n$次
  - 移位方向为向左，商补0
  - 结果中商和余数都为补码
  - **采用末位恒置1法**
- 计算步骤：
  - 初始时，商那边要写成0.0000（**0的数量跟位数有关**）
  - 第一步，若被除数、除数同号，则减除数；异号，则加除数。（**同号减，异号加**。反正做差就对了）
  - 部分余数、商以及该步加减规则：
    - 余数、除数同号，则商上1，这步就减（1）
    - 余数、除数异号，则商上0，这步就加（0）
    - **同号减（1代表负数），异号加（0代表正数）；商上0就加，商上1就减**，总结起来，还是**同号减（1代表负数），异号加（0代表正数）** 这句话最合适
  - **最后一位商恒置1**

### 原码两位乘法
- 符号位不参与运算
  - 计算方式为$\oplus$（**异或，相同为0，不同为1**）
- 每次两位两位的乘，因此会产生4种情况，分别为**0、1、2、3个X**。由于计算机内搞3不方便，所以搞了个欠位C来方便运算
  - 如果位数不是偶数，**则末尾补0**
  - 记忆方法：**高位代表2，低位代表1，欠位也代表1，当需要加3或者4的时候，欠位置1，因为需要下一轮再加，然后根据需要来看是否要减去一个$x$，因为加3直接用加4减1来代替**

    |高位|低位|欠位C|操作|
    |:-:|:-:|:-:|:-:|
    |0|0|0|加0，右移2位，C变0|
    |0|0|1|加$x$，右移2位，C变0|
    |0|1|0|加$x$，右移2位，C变0|
    |0|1|1|加$2x$，右移2位，C变0|
    |1|0|0|加$2x$，右移2位，C变0|
    |1|0|1|加$[-x]_{补}$，右移2位，C变1|
    |1|1|0|加$[-x]_{补}$，右移2位，C变1|
    |1|1|1|加0，右移2位，C变1|
- 对于一个n位的数（不包括符号位）
  - 取双符号位
  - 需要算出$x$、$2x$和$[-x]_补$（算$2x$直接移位）
  - 每次两位两位的乘，运算完后右移两位顶掉多余的
  - 加减次数为$\lceil\cfrac{n}{2}\rceil$次；**如果最后发现欠位还是1，那么得多算一次**
  - 移位次数为$\lceil\cfrac{n}{2}\rceil$次
  - 最后把符号位算上
### 补码两位乘法
- 符号位参与运算
- 每次通过3位来判断到底要干啥，移位每次移2位，**有一个附加位**
  - 记忆方法：最左边代表$-2$，中间右边代表$1$，然后就得出组合值
    |$Y_{i-1}$|$Y_i$|$Y_{i+1}$|组合值|操作|
    |:-:|:-:|:-:|:-:|:-:|
    |0|0|0|0|加0，右移2位|
    |0|0|1|1|加$[x]_{补}$，右移2位|
    |0|1|0|1|加$[x]_{补}$，右移2位|
    |0|1|1|2|加$2[x]_{补}$，右移2位|
    |1|0|0|-2|加$2[-x]_{补}$，右移2位|
    |1|0|1|-1|加$[-x]_{补}$，右移2位|
    |1|1|0|-1|加$[-x]_{补}$，右移2位|
    |1|1|1|0|加0，右移2位|
- 对于一个n位的数（不包含符号位）
  - 取3符号位
  - 需要算出$[x]_{补}$、$2[x]_{补}$、$[-x]_{补}$、$2[-x]_{补}$和$[y]_{补}$
  - **注意，当乘数的n为奇数时，运算次数为$\cfrac{n+1}{2}$，最后一次右移操作只移1位。当乘数的n为偶数时，在乘数最后补一个0，运算次数为$\cfrac{n}{2}+1$，最后一次右移也只移1位**
  - 移位次数与运算次数相同


## 浮点数各种计算
### 浮点数加减法

- 计算步骤：
  - 根据题意将运算数转换为浮点表示。如$6$转换为$0.1100000\times2^3$，$0.3125$转换为$0.1010000\times2^{-1}$
  - 对阶
  - 尾数**双符号位**相加
  - 判断是否溢出以及规格化

### 浮点数乘除法

- 乘法：
  - 尾数相乘
  - 阶码相加
- 除法：
  - 尾数相除
  - 阶码相减

## BCD码各种计算
### BCD码加法
- 计算步骤：
  - 将十进制数转为BCD码，比如2805转换为$(0010\ 1000\ 0000\ 0101)_{BCD}$
  - 对应位数的BCD码相加，若发现大于9，即$1001$时，则需要修正，加上6，即$0110$
  - 得出结果BCD码，然后转换回十进制结果



