[TOC]
# 排序
## 插入排序
### 普通插入排序
- 步骤
  - 不想写了
- 分析
  - **比较次数**
    - **最好情况**
      - 每次外层循环只需要比较一次, 即原数组$A$已经有序
      - $O(n)$
    - **最坏情况**
      - 每次外层循环都需要比较$i-1$次, 即原数组$A$倒序
      - $O(\frac{n^2}{2}) = O(n^2)$
    - **平均情况**
      - 每次外层循环都需要比较$\lceil\frac{i}{2}\rceil$次, 有
      $$\sum_{j=2}^{\lceil\frac{n}{2}\rceil} \leq \frac{n^2}{8}+\frac{n}{4}-1 = \Theta(n^2)$$
      - **移动元素次数**
        - **与比较次数相同**
      - 最终平均时间复杂度$$T(n) = 2* \Theta(n^2) = \Theta(n^2)$$
  - **稳定, 当且仅当比较操作的判断条件是$A[j] > key$而非$A[j]\ge key$**
### 二分插入排序
- 步骤
  - 在插入的时候不是挨个比较$key$和$A[i-1],A[i-2],\cdots$, 而是二分
  比较, 因此**必须使用顺序存储, 即不能用链表**
- 分析
  - **总比较次数**$$\sum_{i=1}^n\lceil\lg i\rceil = n\lg n -n + 1 = O(n\lg n)$$
    - 优于直接插入的平均情况
    - 劣于直接插入的最优情况
  - **总移动次数与直接插入排序相同**
  - 最终时间复杂度$$T(n) = O(n\lg n) + O(n^2) = O(n^2)$$
  - **稳定**
### 插表排序
- 步骤
  - 使用链表存储待排序数组$A$
  - 在插入的时候不是挨个移动元素$A[j+1] = A[j]$, 而是通过**顺序比较**定位到$A[j] < key$后直接将$A[i]$脱链, 然后插入$A[j]$后面
- 分析
  - **总比较次数和直接插入排序相同**
  - 总移动次数为$n*\Theta(1) = \Theta(n)$
  - 最终时间复杂度$$T(n) = O(n^2)+\Theta(n) = O(n^2)$$
## 冒泡排序
- 步骤
  - **起泡**: 从$i=1$开始,$A[i]$与$A[i+1]$比较, 如果$A[i]>A[i+1]$则交换位置, 一直执行到$i=n-1$, **此时$A$中最大的元素位于$A[-1]$**
  - **再起泡**, 到$i=n-2$结束, **此时次大的元素位于$A[-2]$**
  - 重复
  - 可以设置标志`noswap`, 即如果一次起泡没有交换任何元素, 则排序完成
- 分析
  - **最好情况**
    - **初始已经为正序(递增)**
    - $1$次起泡
    - 起泡过程中比较$n-1$次, 不移动任何元素, 有时间复杂度$O(n)$
  - **最坏情况**
    - **初始是倒序(递减)**
    - $n-1$次起泡
    - 每个起泡过程中比较$n-i$次
    - 每次比较由于要**交换元素**, 因此需要移动$3$次
    - 时间复杂度$$T(n) = \sum_{i=1}^{n-1}[(n-i)+3(n-i)] = O(n^2)$$
  - **平均情况**
    - $\frac{n-i}{2}$次起泡
    - 每个起泡过程中比较$n-i$次
    - 每次比较由于要**交换元素**, 因此需要移动$3$次
    - 时间复杂度$O(n^2)$
  - **严格大于才交换, 因此是稳定的**
## 堆排序
### 堆的性质
- 若堆包含$n$个节点, 则其高度为$\lfloor \lg n \rfloor$
  $$2^k\leq n\leq 2^{k+1} - 1\implies \lg (n+1) - 1 \le k \leq \lg(n)  \therefore k =\lfloor \lg n\rfloor =  \Theta(\lg n)$$
- 若堆包含$n$个节点, 则其左子树最多包含$\frac{2}{3}n$个节点(**取不到等**)
- 高度为$h\leq k$的节点所在层最多有$\lceil\frac{n}{2^{h+1}}\rceil$个节点
### 维护堆的性质
- 时间复杂度$\Theta(\lg n)$
- 空间复杂度$\Theta(1)$, 因为交换时需要使用一个额外空间
### 建堆
- 记待排序数组为$A$, 自底向上进行维护堆的性质
- $A[\lfloor\frac{n}{2}\rfloor+1,\cdots,n]$是**堆的叶节点**, 因此不用维护性质
- 从$A[\lfloor\frac{n}{2}\rfloor]$开始**倒序维护性质**
- $$T(n) \leq \sum_{h=0}^{\lfloor\lg n\rfloor}\lceil\frac{n}{2^{h+1}}\rceil O(h) = O(n)$$
- 时间复杂度$O(n)$
### 堆排序
- 步骤
  1. 首先构建最大堆, $O(n)$
  2. 调换$A[1]和A[n]$的位置, $O(1)$
  3. 对$A[1\cdots n-1]$维护堆的性质, $O(lgn)$
  4. 重复第二第三步
- 时间复杂度$O(n\lg n)$
- 空间复杂度$O(1)$
- **最大堆输出递增排序**
- **不稳定**, 因为调换$root$和$A[n-i]$的过程可能会破坏元素之间的相对位置
### 优先级队列
- `EXTRACT-MIN`
  - 时间复杂度$O(\lg n)$
- `INCREASE-KEY`
  - 时间复杂度$O(\lg n)$
- `INSERT`
  - 先放在数组最后, 然后`INCREASE-KEY`
  - 时间复杂度$O(\lg n)$

## 快速排序
### Partition
- 步骤
  - 选出一个$pivot$
  - 将大于$pivot$的元素放在其右边, 小于的放在其左边, 最后返回$pivot$在数组$A$中的位置
  - 时间复杂度$\Theta(n)$
  - 空间复杂度$\Theta(1)$, 因为交换元素需要一个单位的辅助空间
- 不稳定
  - 假设$A[u] = A[v], u<v$且$pivot=A[u]$, 那么首先会把$pivot$与$A[r]$交换, 并且最后肯定有$i > u$, 则最终交换$A[r]$与$A[i]$, 会导致原本的$A[u]$排在$A[v]$的后面

### 快速排序
- 步骤
  - 调用`PARTITION`确定一个中枢节点的位置$p$
  - 分别对$A[1,\cdots,p-1],A[p+1,\cdots,n]$调用`QUICKSORT`
- 分析
  - 最好情况
    - 每次获得的$p$都是在$A$的中心位置, 有$$T(n) = 2T(\frac{n}{2}) + \Theta(n)$$ 有$T(n) = \Theta(n\lg n)$
    - 特别地, 即使划分不均匀, 有$$T(n) = T(\frac{9}{10}n) + T(\frac{1}{10}n) + \Theta(n)$$仍有$T(n) = O(n\lg n)$
  - 最坏情况
    - 每次获得的$p$都是在$A$的末尾/开头位置, 即$A$已经排好序(**按照默认情况有$p=r$, 即$pivot$为$A$中最大元素, 此时最坏情况对应的递增排好序的数组**), 有$$T(n) = T(n-1) + T(1) + \Theta(n)$$有$T(n) = \Theta(n^2)$
  - 平均情况
    - `PARTITION`最多调用$n$次, 每次**调用这个函数**的时间复杂度为$\Theta(1)$, 在所有`PARTITION`调用中一共执行$X$次比较$A[j],pivot$的操作, 因此快速排序时间复杂度理解为$O(n+X)$
    - **根据算法:每一对元素$A[i],A[j](i\ne j)$最多比较1次**
      - 一次调用中每个元素只与调用中的主元进行比较
      - 调用结束后该主元不再与任何元素进行比较
    - **记$X_{i,j}$为$A[i]$和$A[j]$进行比较的事件, 则总比较次数的期望**
    $$E(X) = \sum_{i=1}^n\sum_{j=i+1}^n p(X_{i,j})$$
    - 要求$p(X_{i,j})$
      - 考虑区间$A[i,i+1,\cdots,j]$, **因为所有的比较都发生在主元和其他元素之间, 并且被主元划分开的两个数组中的元素不会发生任何比较**
      - 即如果$\exist A[i]<pivot = x<A[j] $ 则$A[i],A[j]$**一定会被划分在两个集合中, 不会再发生任何比较；**
      - 因此$A[i],A[j]$之间会发生比较**当且仅当**在$A[i,\cdots,j]$中有$$pivot = A[i]\quad or \quad pivot = A[j]$$
      - 而$pivot$**随机**选取, $A[i],A[j]$**被选做$pivot$的事件相互独立**, 因此有$$p(pivot=A[i]\cup pivot=A[j]) = p(X_{i,j}) = \frac{2}{j-i+1}$$
    - 因此有$$\begin{aligned}
      E(X) &= \sum_{i=1}^n\sum_{j=i+1}^n \frac{2}{j-i+1} = \sum_{i=1}^n\sum_{k=1}^{n-i}\frac{2}{k+1}
    \\&< \sum_{i=1}^n\sum_{k=1}^{n}\frac{2}{k} = nO(\lg n) \\&= O(n\lg n)
    \end{aligned}$$
    - 所以最终时间复杂度$$T(n) = O(n+E(X)) = O(n\lg n)$$
  - **空间复杂度平均情况$O(lg n)$, 因为每次调用中需要$\Theta(1)$的辅助空间, 所以有$\lg n$的栈空间**

## 比较排序算法的下界
- 决策树
  - 叶节点是$A[1,\cdots,n]$中所有可能的排序序列, 共$n!$个
  - 决策树的高度$h\ge \lg (n!)\ge n\lg n$
  - 任何一个基于比较的排序, 都需要从决策树的根节点走到叶节点
  - 任何一个基于元素比较的排序, 有时间复杂度下界$\Omega(n\lg n)$

## 计数排序
- 假设
  - $\forall i, A[i]\in\{1,2,\cdots ,k\}$
- 步骤
  - $B[1,\cdots,n]$存放最终输出的有序数组
  - $C[1,\cdots,k]$统计$A[1,\cdots,n]$中每个元素出现的次数, 即$$C[j] = count(A[i] == j)$$
  - 由于$C$数组中对应的$A[i]$元素是有序的(**从$1$到$k$**), 因此可以推算每一个元素在最终的有序数组的(**最后一次出现的**)位置, 即$$\forall j\in\{2,\cdots,k\}\quad C[j] = C[j] + C[j-1]$$
  - 给$B$赋值后将对应元素的位置减一, 即
  $$B[C[A[i]]--] = A[i]$$
    - 如果从前往后遍历$i$, 即$i=1,2,\cdots,n$, 则排序**不稳定**
    - 如果从后往前遍历$i$, 即$i=n,n-1,\cdots,1$, 则排序**稳定**
- 时间复杂度$\Theta(n+k)$
- 空间复杂度$\Theta(n+k)$

## 基排序
- 假设
  - $\forall i, A[i]\in N, ||A[i]|| = d$, 即所有元素都是整数, 整数至多$d$位
- 步骤
  - 对$A[1,\cdots,n]$**从低到高的每一位**调用**稳定排序算法**
- 时间复杂度$O(d\phi(n))$, $\phi(n)$为调用的稳定排序的时间复杂度
  - 如果是**计数排序**, 则有$O(d(n+k))$
- 空间复杂度$O(\psi(n))$, $\psi(n)$为调用的稳定排序的空间复杂度
  - 如果是**计数排序**, 则有$O(n+k)$
- 给定$n$个$b$位数, 以及任意$r<b, r\in N+$, 则基数排序可以在$\Theta(\frac{b}{r}(n+2^r))$的时间内内完成排序
  - 一个$b$位数$x$可以看做是$\frac{b}{r}$个$r$位数, 且一定有$x\leq 2^r - 1$
  - 因此计数排序中有$k=2^r - 1$, 有时间复杂度$O(n+2^r - 1) = O(n+2^r)$
  - 因此最终复杂度为$\Theta(\frac{b}{r}(n+2^r))$
  - 若$b<\lg n$, 则选择$r=b$, 有时间复杂度$\Theta(n)$
  - 若$b\ge \lg n$, 则选择$r=\lg n$, 有时间复杂度$\Theta(\frac{bn}{\lg n})$

## 桶排序
- 假设
  - 输入的分布是$[0,1)$上的均匀分布
- 步骤
  - 给$[0,1)$上均匀构建$n$个链表$B[1,\cdots,n]$(**桶**), 然后将元素分别入桶, 即直接插入链表尾, 有
  $$B[\lfloor n*A[i] \rfloor].append(A[i])$$
  - 在每个链表中运行插入排序
  - **注意不能预先知道元素的最大值/最小值, 因此只能在$[0,1)$上分桶, 而不能在$[min,max]$上分桶**
- 分析
  - 时间复杂度$\Theta(n)$
    - 插入排序的时间复杂度$O(n^2)$
    - 记第$i$个桶中有$X_i$个元素, 则有时间复杂度$$T(n) = O(n) + \sum_{i=1}^n O(X_i^2)$$
    - 求$E(\mathbf{X_i^2})$
      - 记$A[j]$进入$i$桶为事件$X_{i,j}$, 则有$P(X_{i,j}) = \frac{1}{n}$
      $$
      \begin{aligned}
        E(X_i^2) &= E(\sum_{j=1}^n\sum_{k=1}^n P(X_{i,j}) P(X_{i,k}))\\&=E(\sum_{j=1}^nX_{i,j}^2 + \sum_{j=1}^n\sum_{k=1,k\ne j}^n X_{i,j}X_{i,k}) \\ &= \sum_{j=1}^nE(X_{i,j}^2) +  \sum_{j=1}^n\sum_{k=1,k\ne j}^n E( X_{i,j}X_{i,k})
      \end{aligned}
      $$
      - $E(X_{i,j}^2) = 1^2*\frac{1}{n} + 0^2*\frac{n-1}{n} = \frac{1}{n}$, $E(X_{i,j}X_{i,k})) = \frac{1}{n}*\frac{1}{n}=\frac{1}{n^2}$
      
      $$\begin{aligned}
        \implies E(X_i^2) &= \sum_{j=1}^n\frac{1}{n} +  \sum_{j=1}^n\sum_{k=1,k\ne j}^n \frac{1}{n^2} \\&= n*\frac{1}{n}+n*(n-1)*\frac{1}{n^2} \\&= 2-\frac{1}{n}
      \end{aligned}
      $$
    - 因此有$$T(n) = O(n) + \sum_{i=1}^n O(2-\frac{1}{n}) = \Theta(n)$$
    - 最坏情况: 所有数分到一个桶, 有$T(n)= O(n^2)$
  - 空间复杂度$O(n)$
# 选择
## 问题描述
输入$A[1,\cdots,n]$和$i$,输出$A$中第$i$大的元素
## 选择最小值/最大值
- 仅需遍历一次$A$, 进行$n-1$次比较
- 时间复杂度$\Theta(n)$
## 同时选择最小值和最大值
- 成对处理$A[i],A[i+1]$, 先比较两个输入元素, 大的那个和$max$比较, 小的那个和$min$比较
- 一共需要比较$\frac{3(n-1)}{2}$次($n$为奇)/$\frac{3(n-2)}{2} + 1$次($n$为偶)
- 时间复杂度$\Theta(n)$

## 期望为线性时间的选择算法
- 步骤
  - 参照快排, 对数组进行`RANDOMIZED-PARTITION`, 返回$q$, 由于$A[p,\cdots,q-1]<A[q]$, $A[q+1,\cdots,n]>A[q]$, 因此$q$为$A[p,\cdots,r]$中第$k = q-p+1$小的元素位置, 即**有$k$个值小于$A[q]$**
  - 如果$k==target$, 则找到了
  - 如果$k<target$, 那么需要往$A[q+1,\cdots,n]$里找, 现在已经有$k$个值小于$A[q]$, 则在$A[q+1,\cdots,n]$中找第$target-k$小的元素, 即`Select(q+1,n,target-k)`
  - 如果$k>target$, 那么需要往$A[p,\cdots,q-1]$里找, 这里的所有元素都小于$A[q]$, 因此继续找第$target$小的元素即可, 即`Select(p,q-1,target)`
- 分析
  - 好情况
    - 每次能去掉一部分$n$, 即$$\exist \alpha < 1\quad T(n) =T(\alpha n) + \Theta(n) \implies T(n) = \Theta(n)$$
  - 坏情况
    - 每次只能去除一个值, 即$$T(n) = T(n-1)+\Theta(n)\implies T(n) = \Theta(n^2)$$
  - 平均分析
    - <font color="red">这个假设有屁用?</font>假设第$target$小的元素出现在$A[q+1,\cdots,r]$中
    - 记$X_k$为子数组$A[p,\cdots,q]$中恰好出现$k$个元素的事件, 则有$$P(X_k) = \frac{1}{n}(n = q-p+1)$$
    - 有$$\begin{aligned}
      T(n)&\leq \sum_{k=1}^np(X_k)*[T(max(k-1,n-k)) + \Theta(n)] \\&= \sum_{k=1}^np(X_k)*T(max(k-1,n-k)) + \Theta(n)
    \end{aligned}$$
    - 概率意义的平均情况下, 有
  $$
  \begin{aligned}
    E(T(n))&\leq E(\sum_{k=1}^np(X_k)*T(max(k-1,n-k)) + \Theta(n))\\&= \sum_{k=1}^np(X_k)*E(T(max(k-1,n-k)) + \Theta(n)) \\ &= \sum_{k=1}^n\frac{1}{n}*E(T(max(k-1,n-k)) + \Theta(n))
  \end{aligned}
  $$
  - 如果$n$是偶数, $T(\frac{n}{2})$到$T(n-1)$的每一项都出现两次, 如果$n$是奇数, 则$T(\lfloor\frac{n}{2}\rfloor)$出现一次, 其余都出现两次, 则有$$E(T(n)) \leq \frac{2}{n}\sum_{k=\lfloor\frac{n}{2}\rfloor}^{n-1}E(T(k)) + O(n)$$
  - 使用**代入法**, 得证$E(T(n)) = O(n)$
## 最坏情况是线性时间的选择算法
- 步骤
  - 将$A[1,\cdots,n]$分为$\lceil \frac{n}{5}\rceil$组, 每一组内插入排序, 取出每一组的中位数得到长度为$\lceil \frac{n}{5}\rceil$的中位数组
  - 递归调用自身找**中维数组的中位数$x$**
  - 用$x$作为$pivot$进行`PARTITION(p,r,x)`, 记$x$为$A[p,\cdots,q]$中第$k$小的
  - 如果$k = target$, 则直接返回
  - 如果$k < target$, 则取右边的一半找第$target-k$大
  - 如果$k > target$, 则取左边的一半找第$targek$大
- 分析
  - 对$\lceil \frac{n}{5}\rceil$组进行插入排序, 每一组内最多有$5$个元素, 则总时间复杂度$n*O(5) = O(n)$
  - 查找中位数组的中位数, 有时间复杂度$T(\lceil \frac{n}{5}\rceil)$
  - $A[p,\cdots,r]$中至少有$\lceil\frac{1}{2}\lceil\frac{n}{5}\rceil\rceil - 2$组中有$3$个元素大于等于$x$, 则至少有$$3*(\lceil\frac{1}{2}\lceil\frac{n}{5}\rceil\rceil - 2)\ge \frac{3n}{10} - 6$$个元素大于等于$x$, 从而最多有$$n-\frac{3n}{10} - 6  = \frac{7n}{10}+6$$个元素小于等于$x$, 因此有$$T(max(k-1),(n-k)) = T(\frac{7n}{10}+6)$$
  - 因此总时间复杂度有$$T(n) \leq T(\lceil \frac{n}{5}\rceil) + T(\frac{7n}{10}+6) + O(n)$$
  - **代入法求解**
  - 得$n\ge 140$时, 存在$c=20a$, 其中$a$为插入排序$O(n)$的系数, 使得$$T(n) \leq cn = O(n)$$
- **$n$为偶数时, 最少$6$个元素分一组**
- **$n$为奇数时, 最少$5$个元素分一组**