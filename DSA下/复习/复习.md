<h1>算法导论复习</h1>

[toc]

选择 20分 不定项选择  都是些基础概念
简答
分析 时间复杂度
证明题

## 算法复杂度符号表示
## 递归与分治
### 递归式
- 表达与求解递归式时一般要忽略一些技术性细节
  - 函数自变量为整数，忽略上取整和下取整
  - 忽略边界条件，假设对于足够小的$n$，$T(n)$为常量
- 代入法
  - 先猜测有某个界存在，然后用数学归纳法证明猜测的正确性
  - 步骤
    - 猜测解的形式
    - 用数学归纳法证明，找出使解真正有效的常数
    - 确定常数使边界条件成立
  - 有些时候发现次数对了，但归纳的时候还差一点，那就加强归纳假设，把假设的式子**减去一个低阶项**
  - 有些时候还可以进行变量替换
- 迭代法
  - 把递归式转化为求和表达式，然后再求这个式子的边界
  - 步骤
    - 把递归式不断展开然后求和就可以了
  - 有时可以只展开部分，然后看出规律来用代入法
  - 有时递归式会包含向上取整或向下取整，这时候可以假设$n$是某个常数的幂次方来简化，如$n=2^k$
- 递归树法
  - 用树形结构直观地表达了迭代式
  - 每个结点都代表该步代价；每一层都是一次递归调用的结果；而把每一层中的结点都相加，就得到了该次递归调用的代价
  - 步骤
    - 不断地展开树，然后把每层相加
    - 把每层的结果求和
  - 严格意义上说，递归树法的结果需要再用代入法来验证
- 主方法
  - 给出了求解$T(n)=aT(\cfrac{n}{b})+f(n)$这种形式递归式的简单方法（就是可以直接套公式）
  - 其中，常数$a\ge1$和常数$b>1$，$f(n)$是一个渐进正函数。$\cfrac{n}{b}$可以是带取整符号的
  - 判断方法
    - 若对某个常数$\epsilon>0$，有$f(n)=O(n^{\log_{b}a-\epsilon})$，则$T(n)=\Theta(n^{\log_{b}a})$
    - 若$f(n)=O(n^{\log_{b}a})$，则$T(n)=\Theta(n^{\log_{b}a}\log n)$
    - 若对某常数$\epsilon>0$，有$f(n)=O(n^{\log_{b}a+\epsilon})$，且对某个常数$c<1$和所有足够大的$n$，有$af(\cfrac{n}{b})\le cf(n)$，则$T(n)=\Theta(f(n))$
### 分治策略
- Strassen矩阵乘法
  - 将计算两个$n$阶矩阵的乘积所需的时间减少到了$O(n^{log7})$
  - 可以将矩阵写为如下形式：
$$
\left[
\begin{matrix}
    C_{11}\ \ C_{12}\\
    C_{21}\ \ C_{22}
\end{matrix}
\right]=
\left[
\begin{matrix}
    A_{11}\ \ A_{12}\\
    A_{21}\ \ A_{22}
\end{matrix}
\right]
\left[
\begin{matrix}
    B_{11}\ \ B_{12}\\
    B_{21}\ \ B_{22}
\end{matrix}
\right]
$$
  - 传统的计算$C$会总共需要8次乘法以及4次加法，这样虽然可以递归解，但还是$O(n^3)$
  - Strassen矩阵乘法把其变成了7次乘法以及18次加法，由于加法开销比乘法小很多，因此复杂度下降了。参考第2章PPT第63页起
- 最大子数组
  - 在一个数组里边找一段合最大的数组，被称为最大子数组
  - 递归策略
    - 最大子数组位于中点左边：在中点左侧的数组进行递归
    - 最大子数组位于中点右边：在中点右侧的数组进行递归
    - 最大子数组位于中间：从中间往两边一个一个找
  - 递归式为$T(n)=2T(\cfrac{n}{2})+n$
- 大整数乘法

- 多数算法
  - 给定一个大小为$n$的数组，找出其中出现次数超过$\cfrac{n}{2}$的元素
  - 蛮力法（暴力搜索）
    - 时间复杂度$O(n^2)$，空间复杂度$O(n)$
  - 哈希法
    - 时间复杂度$O(n)$，空间复杂度$O(n)$
  - 先排序再搜索
    - 如果多数存在，那么就是中位数。于是从中位数向左右两边搜索，看看是不是个数是不是超过一半
    - 时间复杂度$O(n\log n)$
  - 分治法
    - 思路
      - 分别找左边的多数与右边的多数。
      - 如果左边的结果等于右边的结果，那这个就是多数
      - 如果不一样则遍历该数组看看哪个是
    - 递归式$T(n)=2T(\cfrac{n}{2})+O(n)$。所以时间复杂度$O(n\log n)$，空间复杂度$O(n)$

## 概率分析与随机算法（不考）
## 排序
### 堆排序
- 堆排序的关键是**堆**这种数据结构。一般来说可以用数组来实现堆
- 父节点与子结点的关系
  - $PARENT[i]=\lfloor i/2\rfloor$
  - $LEFT[i]=2i$，$RIGHT[i]=2i+1$
- 堆结构的基本操作
  - $MAX-HEAPIFY$：保持最大堆性质，$O(\log n)$
  - $BUILD-MAX-HEAP$：构造最大堆，$O(n)$
  - $HEAPSORT$：排序，$O(n\log n)$
  - $MAX-HEAP-INSERT$、$HEAP-EXTRACT-MAX$、$HEAP-INCREASE-KEY$、$HEAP-MAXIMUM$：都是$O(\log n)$
### 快速排序
### 线性时间排序
### 排序算法比较
## 动态规划

## 贪心算法
## 摊还分析（不考）
## 图算法
## 最大流
## NP完全理论